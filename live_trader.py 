import asyncio
from typing import List
from datetime import datetime
from alpaca.trading.client import TradingClient
from alpaca.trading.requests import MarketOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce, OrderClass
from alpaca.data.live import StockDataStream
from alpaca.data.enums import DataFeed
from strategy import BaseStrategy, Position, Signal
from config import settings
from risk import check_drawdown


class LiveTrader:
    """Execute live trades based on strategy signals"""
    
    def __init__(self, strategy: BaseStrategy):
        self.strategy = strategy
        self.trading_client = TradingClient(
            settings.alpaca_key,
            settings.alpaca_secret,
            paper=settings.paper
        )
        self.positions: dict[str, Position] = {}
        self.market_data: dict = {}
        self.allow_trading = settings.allow_trading
        
        # Risk limits
        self.max_position_size = settings.max_usd_per_order
        self.max_daily_loss = settings.max_daily_loss
        self.daily_pnl = 0.0
        
        # Stats
        self.total_trades = 0
        self.winning_trades = 0
        self.losing_trades = 0
    
    async def submit_order(self, symbol: str, side: OrderSide, notional: float):
        """Submit market order"""
        if not self.allow_trading:
            print(f"üí§ Trading disabled. Would {side.name} ${notional:.2f} of {symbol}")
            return None
        
        try:
            req = MarketOrderRequest(
                symbol=symbol,
                notional=notional,
                side=side,
                time_in_force=TimeInForce.DAY,
                order_class=OrderClass.SIMPLE
            )
            order = self.trading_client.submit_order(req)
            print(f"‚úÖ Order submitted: {side.name} ${notional:.2f} of {symbol}")
            self.total_trades += 1
            return order
        except Exception as e:
            print(f"‚ùå Order failed: {e}")
            return None
    
    def check_risk_limits(self) -> bool:
        """Check if we're within risk limits"""
        return check_drawdown(self.daily_pnl, self.max_daily_loss)
    
    async def process_signals(self, signals: List[Signal]):
        """Process trading signals"""
        if not self.check_risk_limits():
            return
        
        try:
            account = self.trading_client.get_account()
            account_value = float(account.equity)
            
            for signal in signals:
                if signal.action == 'buy' and signal.symbol not in self.positions:
                    # Calculate position size
                    size = self.strategy.get_position_size(
                        signal.symbol, 
                        account_value, 
                        signal.confidence
                    )
                    size = min(size, self.max_position_size)
                    
                    # Submit order
                    order = await self.submit_order(signal.symbol, OrderSide.BUY, size)
                    
                    if order and signal.symbol in self.market_data:
                        price = self.market_data[signal.symbol]['close']
                        shares = size / price
                        
                        self.positions[signal.symbol] = Position(
                            symbol=signal.symbol,
                            shares=shares,
                            entry_price=price,
                            current_price=price,
                            entry_time=datetime.now(),
                            pnl=0.0,
                            pnl_pct=0.0
                        )
                        print(f"üìä Position opened: {signal.symbol} @ ${price:.2f} | {signal.reason}")
                
                elif signal.action == 'sell' and signal.symbol in self.positions:
                    # Close position
                    pos = self.positions[signal.symbol]
                    notional = pos.shares * pos.current_price
                    
                    order = await self.submit_order(signal.symbol, OrderSide.SELL, notional)
                    
                    if order:
                        self.daily_pnl += pos.pnl
                        
                        if pos.pnl > 0:
                            self.winning_trades += 1
                            print(f"üí∞ Position closed: {signal.symbol} @ ${pos.current_price:.2f} | Profit: ${pos.pnl:.2f} ({pos.pnl_pct*100:.2f}%)")
                        else:
                            self.losing_trades += 1
                            print(f"üìâ Position closed: {signal.symbol} @ ${pos.current_price:.2f} | Loss: ${pos.pnl:.2f} ({pos.pnl_pct*100:.2f}%)")
                        
                        del self.positions[signal.symbol]
        
        except Exception as e:
            print(f"Error processing signals: {e}")
    
    async def handle_bar(self, bar):
        """Handle incoming bar data"""
        symbol = bar.symbol
        
        # Update market data
        self.market_data[symbol] = {
            'open': bar.open,
            'high': bar.high,
            'low': bar.low,
            'close': bar.close,
            'volume': bar.volume
        }
        
        # Update positions
        if symbol in self.positions:
            pos = self.positions[symbol]
            pos.current_price = bar.close
            pos.pnl = (bar.close - pos.entry_price) * pos.shares
            pos.pnl_pct = (bar.close - pos.entry_price) / pos.entry_price
            
            # Check exit
            if self.strategy.should_exit(pos, self.market_data):
                print(f"üõë Exit signal for {symbol}: PnL {pos.pnl_pct*100:.2f}%")
                
                notional = pos.shares * bar.close
                order = await self.submit_order(symbol, OrderSide.SELL, notional)
                
                if order:
                    self.daily_pnl += pos.pnl
                    
                    if pos.pnl > 0:
                        self.winning_trades += 1
                        print(f"üí∞ Position closed: {symbol} | Profit: ${pos.pnl:.2f}")
                    else:
                        self.losing_trades += 1
                        print(f"üìâ Position closed: {symbol} | Loss: ${pos.pnl:.2f}")
                    
                    del self.positions[symbol]
                return
        
        # Generate signals
        signals = self.strategy.generate_signals(self.market_data)
        
        if signals:
            print(f"üì° Generated {len(signals)} signals")
            await self.process_signals(signals)
    
    async def run(self, symbols: List[str]):
        """Start live trading"""
        print("\n" + "="*80)
        print(f"ü§ñ Starting {self.strategy.name} Trading Bot")
        print("="*80)
        print(f"Mode: {'PAPER' if settings.paper else 'LIVE'} Trading")
        print(f"Trading: {'ENABLED' if self.allow_trading else 'DISABLED'}")
        print(f"Symbols: {', '.join(symbols)}")
        print(f"Max Position Size: ${self.max_position_size}")
        print(f"Max Daily Loss: ${self.max_daily_loss}")
        print("="*80 + "\n")
        
        feed_map = {"iex": DataFeed.IEX, "sip": DataFeed.SIP}
        feed = feed_map.get(settings.feed.lower(), DataFeed.IEX)
        
        while True:
            try:
                stream = StockDataStream(
                    settings.alpaca_key,
                    settings.alpaca_secret,
                    feed=feed
                )
                
                # Subscribe to all symbols
                for symbol in symbols:
                    stream.subscribe_bars(self.handle_bar, symbol.strip())
                
                print(f"üì° Subscribed to {len(symbols)} symbols on {feed.name}")
                await stream.run()
            
            except Exception as e:
                print(f"‚ùå Stream error: {e}")
                print("Reconnecting in 5 seconds...")
                await asyncio.sleep(5)